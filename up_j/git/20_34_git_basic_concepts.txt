Понятия: комит, индекс, ветка, тег, ориджин. Как создать ветку, переключаться между ветками, внести изменения,
подтягивать изменения с удаленного репозитория. reset, checkout, как удалить комит из ветки?

1) "Три дерева git" - три внутреннич механизма управления состоянием git
  - дерево коммитов (commit-tree);
  - раздел проиндексированных файлов (stage);
  - рабочий каталог (working directory).

  К примеру есть файл "some.txt", его содержимое на данный момент:
    [
      some_1
      some_2
      some_3
    ]

    - some_1 - существует на уровне коммита;
    - some_2 - существует на уровне stage (внесенное вами и проиндексированное изменение);
    - some_3 - существует на уровне рабочего каталога (внесенное вами но еще непроиндексированное изменение).


2) Индекс (index, stage) - это специальная промежуточная область, в которой хранятся изменения файлов на пути
  от рабочей директории (working directory) до репозитория. При выполнении коммита в него попадают только те
  изменения, которые были добавлены в stage area.

  git add index.html - добавить содержимое файла в stage
  git add .

3) commit - сохранение, фиксация (в архиве, репозитарии и др.) изменений в программном коде.

  git commit file_name -m (message) 'Add some code'
  git log --oneline - просмотр журнала коммитов

4) branch (ветка) - представляет собой отдельное направление разработки.
  Ветки выступают в качестве абстрактного представления для процесса редактирования/индексации/коммита.
  Новые коммиты записываются в историю текущей ветки, что приводит к образованию развилки в истории проекта.

5) HEAD — указатель на текущую ветку, которая, в свою очередь, является указателем на последний коммит,
  сделанный в этой ветке. Это значит, что HEAD будет родителем следующего созданного коммита.

6) tag - это ссылка, указывающая на определенную точку в истории Git. Команда git tag обычно используется для
  захвата некой точки в истории, которая используется для релиза нумерованной версии (например, v1.0.1).
  По умолчанию команда git tag создает тег для коммита, на который ссылается указатель HEAD. Вместо этого в
  git tag можно передать ссылку на конкретный коммит.

  - git tag -a v1.4 -m "my version 1.4" - создание аннотированного тега;

  - git tag v1.4-lw - создание легковесного.

7) origin - В процессе клонирования с помощью команды git clone автоматически создается удаленное подключение
  к исходному репозиторию (такое соединение называется origin). Это позволяет разработчикам, создающим
  локальную копию центрального репозитория, легко загружать изменения или публиковать локальные коммиты.

8) создание ветки, переход
  - git branch <branch> - создание ветки;
  - git checkout -b ＜new-branch＞ ＜existing-branch＞ - создание новой ветки от ветки <existing-branch> и переход на неё;

  - git checkout ＜branchname＞ - переключится на ветку <branchname>;

9) внесение изменений
  - git status - отображает пути, которые имеют различия между индексным файлом и текущим фиксацией HEAD,
    пути, которые имеют различия между рабочим деревом и индексным файлом, и пути в рабочем дереве,
    которые не отслеживаются git и не игнорируются gitignore;

  - [git add . -> git commit -m 'message'] - внести изменения на текущую ветку локально;

  - git push <remote> <branch> - выгрузить содержимое локального репозитория в удаленный репозиторий на
    указанную ветку;


10) Подтянуть изменения
  - git pull - извлечение и загрузка содержимого из удаленного репозитория и немедленное обновление
    локального репозитория.

11) reset - откат состояния
  - универсальный инструмент для отмены изменений. Имеет три основные формы вызова, соответствующие аргументам
    командной строки --soft, --mixed, --hard. Каждый из этих трех аргументов соответствует трем внутренним
    механизмам управления состоянием git.

    Рассмотрим пример - имея историю коммитов, применим к ней:

    commit_A <- HEAD
      change_A - в commit-tree
      change_B - в commit-tree
    commit_B
    ...

  - git reset --soft <commit_B> - указатель HEAD переходит на commit_B, изменения commit_A остаются в stage;

      change_A - в stage area
    commit_B <- HEAD
      change_B - в commit-tree
    ...

  - git reset --mixed <commit_B> - указатель HEAD переходит на commit_B, изменения commit_A удаляются из stage;

      change_A - в working directory
    commit_B <- HEAD
      change_B - в commit-tree
    ...

  - git reset --hard <commit_B> - указатель HEAD переходит на commit_B, изменения commit_A удаляются из stage и из working directory;

    commit_B <- HEAD
      change_B - в commit-tree
    ...