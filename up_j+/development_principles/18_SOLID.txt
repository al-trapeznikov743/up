SOLID (single responsibility, open–closed, Liskov substitution, interface segregation и dependency
inversion) в программировании — мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers)
для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали 5 основных
принципов объектно-ориентированного программирования и проектирования.

При создании программных систем использование принципов SOLID способствует созданию такой системы,
которую будет легко поддерживать и расширять в течение долгого времени.

S - SRP - single responsibility principle (принцип единственной ответственности)
  У каждого класса (компонента, метода, функции) должна быть своя четко обозначенная зона
  ответственности. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в
  этот класс и подчинены только этой задаче.

  Антипод SRP - God object (объект бога) - антипаттерн объектно-ориентированного программирования,
  описывающий объект, который хранит в себе "слишком много" или делает "слишком много".

O - OCP - open-closed principle (принцип открытости/закрытости)
  Программные сущности должны быть открыты для расширения, но закрыты для модификации.

  "Более логично и рационально добавлять новый функционал не за счет изменения существующих сущностей, 
  а за счет добавления новой сущности посредством композиции (агрегирования) и наследования"

L - LSP - Liskov substitution principle (принцип подстановки Барбары Лисков)
  Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности
  выполнения программы.

  "Поведение наследующих классов не должно противоречить поведению базового класса"

  "Если вы имеете код, в который приходит базовый класс (parent), то в этот же код без каких-либо
  помех, exception-ов, падений должен при ходить его наследник"

I - ISP - interface segregation principle (принцип разделения интерфейса)
  Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего
  назначения.

  Make fine grained interfaces that are client specific - создавайте детализированные интерфейсы
  для конкретных клиентов.

  "Интерфейс является принадлежностью клиента, а не сервера, и должен формироваться исходя из
  потребностей клиента" - то есть создаём не общий интерфейс под все возможности "сервера", а
  несколько интерфейсов, содержащих в себе часть функционала сервера, необходимую конкретному
  клиенту.
 
D - DIP - dependency inversion principle (принцип инверсии зависимостей)
  Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны
  зависеть от абстракций.
  Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

  Как формулирует Сергей Немчинский - "вы должны использовать все классы через интерфейсы"

  "Идея в том что сущность не должна зависеть от конкретной реализации, а должна зависеть от какой-либо
  абстракции, реализации которой могут быть различны"